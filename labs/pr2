import math
import matplotlib.pyplot as plt
def f(x):
    a=2
    b=2
    c=-5
    return x**a+((b*x)**(1/3))/(c*x+a)
x=1
result=f(x)
print(result)
    pass


def circle_area(radius):
    return radius**2*math.pi
r=2
S=circle_area(r)
print(S)
    pass


def point_in_area1(x, y):
    return (y <= x) and (y >= 0) and (y <= x)

def point_in_area2(x, y):
    return ((x - 10)**2 + y**2) >= 25 and y >= 10 and x <= 10

def check_areas():
    while True:
        x = float(input('x='))
        y = float(input('y='))

        if point_in_area1(x, y):
            if point_in_area2(x, y):
                print('Попала в обе')
            else:
                print('Попала в 1')
        else:
            if point_in_area2(x, y):
                print('Попала в 2')
            else:
                print('Никуда')
check_areas()
    pass


def r():
    count=0
    for i in range(0,9):
        count+=2*i
    return count
print(r())
    pass


def p():
    count1=0
    count2=1
    for i in range(5):
        for j in range(i+1):
            count2+=(i+j)**2
        count1+=count2
        count2=1
    return count1
print(p())
    pass


def m():
    count1 = 0
    count2 = 1
    for i in range(9):
        for j in range(2*i + 1):
            count2 += i**2+j**3
        count1 += count2
        count2 = 1
    return count1
print(m())
    pass


def z(x):
    if x>=0:
       z=x**2+5
    else: z=5*math.cos(x)
    return z
print(z(0))
    pass


def plot(a, b, n):
    x_vector = [a + i * (b - a) / (n - 1) for i in range(n)]
    y_vector = [z(x) for x in x_vector]
    plt.grid()
    plt.plot(x_vector, y_vector, 50)
    plt.show()
plot(0, 10, 100)
    pass


def array1d(n):
    array = 'a '* n
    print(array)
array1d(5)
    pass


def array2d_2(n):
    for i in range(len(n)):
        for j in range(len(n[i])):
            if i == j:
                print('z', end=' ')
            else:
                print('.', end=' ')
        print()
n = [['z' for j in range(5)] for i in range(5)]
print(array2d_2(n))
    pass


def array2d_2(n):
    """задание 6.3 (оценка 5)"""
    pass

def cat(filename):
    with open('1e', "r") as file:
        print(file.read())
cat('Текст')
    pass


def write(filename):
    """задание 7.2 (оценка 5)"""
    pass


ГОТОВЫЙ КОД:
from PyQt5.QtWidgets import (
 QApplication,
 QLabel,
 QLineEdit,
 QMainWindow,
 QPushButton,
 QVBoxLayout,
 QWidget,
 QSpinBox,
 QMessageBox,
 QFileDialog,
 QComboBox
)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.range_label = QLabel("Диапазон:")
        self.range_start_input = QLineEdit('-1')
        self.range_end_input = QLineEdit('1')

        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

        # Добавление возможности выбора количества точек на графике:
        self.points_label = QLabel("Количество точек:")
        self.points_input = QSpinBox()
        self.points_input.setMinimum(2)  # Минимальное количество точек
        self.points_input.setMaximum(1000)  # Максимальное количество точек
        self.points_input.setValue(50)  # Значение по умолчанию
        layout.addWidget(self.points_label)
        layout.addWidget(self.points_input)

        # Создаем кнопку для очистки графика
        self.clear_button = QPushButton('Очистить график', self)
        self.clear_button.clicked.connect(self.clear_plot)

        # Добавляем кнопку очистки графика
        layout.addWidget(self.clear_button)

        # Создаем кнопку для сохранения точек
        self.save_button = QPushButton('Сохранить точки', self)
        self.save_button.clicked.connect(self.save_points)

        # Добавляем кнопку сохранения точек
        layout.addWidget(self.save_button)

        # Создаем виджет списка для функций
        self.function_list_label = QLabel("Список функций:")
        self.function_list = QComboBox()
        layout.addWidget(self.function_list_label)
        layout.addWidget(self.function_list)

        # Добавляем обработчик события выбора функции из списка
        self.function_list.currentIndexChanged.connect(self.select_function_from_list)

    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1

        # Получаем количество точек из QSpinBox
        num_points = self.points_input.value()

        x = np.linspace(range_start, range_end, num_points)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        try:
            functions = {}  # определим словарь функций
            exec(f"def f(x): return {expression}", functions)
            function = functions["f"]

            x = np.linspace(range_start, range_end, num_points)
            y = [function(value) for value in x]

            plt.title('График функции ' + expression)

            plt.plot(x, y)
            plt.grid(True)

            plt.xlabel('x')
            plt.ylabel('y')
            # Добавляем функцию в виджет списка, если она не была добавлена ранее
            current_function = self.function_input.text()
            if current_function not in [self.function_list.itemText(i) for i in range(self.function_list.count())]:
                self.function_list.addItem(current_function)
            # Обработка ошибки ввода неверной функции
            self.centralWidget().layout().itemAt(0).widget().draw()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при построении графика: {e}")


    def clear_plot(self):
        # Очищаем график
        plt.clf()
        # Обновляем виджет с полотном Matplotlib
        self.centralWidget().layout().itemAt(0).widget().draw()

    def save_points(self):
        # Получаем данные для сохранения
        range_start = float(self.range_start_input.text())
        range_end = float(self.range_end_input.text())
        expression = self.function_input.text()
        num_points = self.points_input.value()

        try:
            functions = {}  # Определим словарь функций
            exec(f"def f(x): return {expression}", functions)
            function = functions["f"]

            x = np.linspace(range_start, range_end, num_points)
            y = [function(value) for value in x]

            # Открываем диалоговое окно сохранения файла
            file_path, _ = QFileDialog.getSaveFileName(self, 'Сохранить точки', '', 'Текстовые файлы (*.txt)')

            if file_path:
                with open(file_path, 'w') as file:
                    for i in range(len(x)):
                        file.write(f'{x[i]}, {y[i]}\n')

                QMessageBox.information(self, 'Сохранение', 'Точки успешно сохранены в файл.')
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при сохранении точек: {e}")

    def select_function_from_list(self):
        selected_function_index = self.function_list.currentIndex()
        if selected_function_index >= 0:
            selected_function = self.function_list.itemText(selected_function_index)
            self.function_input.setText(selected_function)

# Создать приложение QApplication
app = QApplication([])
# Создать окно приложения
main_window = MainWindow()
main_window.show()
# Запустить приложение
app.exec_()

2 ЗАДАНИЕ
from PyQt5.QtWidgets import (QApplication, QLabel, QLineEdit, QMainWindow, QPushButton, QVBoxLayout, QWidget, QSpinBox, QMessageBox, QFileDialog, QComboBox)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

        # Добавление возможности выбора количества точек на графике:
        self.points_label = QLabel("Количество точек:")
        self.points_input = QSpinBox()
        self.points_input.setMinimum(2)  # Минимальное количество точек
        self.points_input.setMaximum(1000)  # Максимальное количество точек
        self.points_input.setValue(50)  # Значение по умолчанию
        layout.addWidget(self.points_label)
        layout.addWidget(self.points_input)

        # Создаем кнопку для очистки графика
        self.clear_button = QPushButton('Очистить график', self)
        self.clear_button.clicked.connect(self.clear_plot)

        # Добавляем кнопку очистки графика
        layout.addWidget(self.clear_button)

        self.bisection_method = QLabel('Интервал на графике:', self)
        layout.addWidget(self.bisection_method)

        self.range_start_input = QLineEdit()
        layout.addWidget(self.range_start_input)

        self.range_end_input = QLineEdit()
        layout.addWidget(self.range_end_input)

        self.bisection_button = QPushButton("Выполнить метод половинного деления")
        layout.addWidget(self.bisection_button)


    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1

        # Получаем количество точек из QSpinBox
        num_points = self.points_input.value()

        x = np.linspace(range_start, range_end, num_points)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        try:
            functions = {}  # определим словарь функций
            exec(f"def f(x): return {expression}", functions)
            function = functions["f"]

            a = range_start
            b = range_end

            x = np.linspace(range_start, range_end, num_points)
            y = [function(value) for value in x]

            plt.title('График функции ' + expression)

            plt.plot(x, y)
            plt.grid(True)

            plt.xlabel('x')
            plt.ylabel('y')
            # Добавляем функцию в виджет списка, если она не была добавлена ранее
            # Обработка ошибки ввода неверной функции
            self.centralWidget().layout().itemAt(0).widget().draw()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при построении графика: {e}")


    def clear_plot(self):
        # Очищаем график
        plt.clf()
        # Обновляем виджет с полотном Matplotlib
        self.centralWidget().layout().itemAt(0).widget().draw()

    def bisection_method(self):
        a = self.range_start_input.text()
        b = self.range_end_input.text()

        if function(a) * function(b) > 0:
            raise ValueError("Функция должна иметь разные знаки на концах интервала")

        iter_count = 0
        while (b - a) / 2 > tol and iter_count < max_iter:
            c = (a + b) / 2
        if function(c) == 0:
            return c
        elif function(c) * function(a) < 0:
            b = c
        else: a = c
        iter_count += 1

        return (a + b) / 2

        self.centralWidget().layout().itemAt(0).widget().draw()

        result_label.setText(str(result))

    def execute_bisection_method(self):
        try:
            result = self.bisection_method()
        except ValueError as e:
            error_label.setText(str)
# Создать приложение QApplication
app = QApplication([])
# Создать окно приложения
main_window = MainWindow()
main_window.show()
# Запустить приложение
app.exec_()


попытки:
from PyQt5.QtWidgets import (
 QApplication,
 QLabel,
 QLineEdit,
 QMainWindow,
 QPushButton,
 QVBoxLayout,
 QWidget,
 QSpinBox,
 QMessageBox,
 QFileDialog,
 QComboBox
)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.range_label = QLabel("Диапазон:")
        self.range_start_input = QLineEdit('-1')
        self.range_end_input = QLineEdit('1')

        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

        # Добавление возможности выбора количества точек на графике:
        self.points_label = QLabel("Количество точек:")
        self.points_input = QSpinBox()
        self.points_input.setMinimum(2)  # Минимальное количество точек
        self.points_input.setMaximum(1000)  # Максимальное количество точек
        self.points_input.setValue(50)  # Значение по умолчанию
        layout.addWidget(self.points_label)
        layout.addWidget(self.points_input)

        # Создаем кнопку для очистки графика
        self.clear_button = QPushButton('Очистить график', self)
        self.clear_button.clicked.connect(self.clear_plot)

        # Добавляем кнопку очистки графика
        layout.addWidget(self.clear_button)

        # Создаем кнопку для сохранения точек
        self.save_button = QPushButton('Сохранить точки', self)
        self.save_button.clicked.connect(self.save_points)

        # Добавляем кнопку сохранения точек
        layout.addWidget(self.save_button)

    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1

        # Получаем количество точек из QSpinBox
        num_points = self.points_input.value()

        x = np.linspace(range_start, range_end, num_points)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        try:
            functions = {}  # определим словарь функций
            exec(f"def f(x): return {expression}", functions)
            function = functions["f"]

            x = np.linspace(range_start, range_end, num_points)
            y = [function(value) for value in x]

            plt.title('График функции ' + expression)

            plt.plot(x, y)
            plt.grid(True)

            plt.xlabel('x')
            plt.ylabel('y')

            # Обработка ошибки ввода неверной функции
            self.centralWidget().layout().itemAt(0).widget().draw()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при построении графика: {e}")


    def clear_plot(self):
        # Очищаем график
        plt.clf()
        # Обновляем виджет с полотном Matplotlib
        self.centralWidget().layout().itemAt(0).widget().draw()

    def save_points(self):
        # Получаем данные для сохранения
        range_start = float(self.range_start_input.text())
        range_end = float(self.range_end_input.text())
        expression = self.function_input.text()
        num_points = self.points_input.value()

        try:
            functions = {}  # Определим словарь функций
            exec(f"def f(x): return {expression}", functions)
            function = functions["f"]

            x = np.linspace(range_start, range_end, num_points)
            y = [function(value) for value in x]

            # Открываем диалоговое окно сохранения файла
            file_path, _ = QFileDialog.getSaveFileName(self, 'Сохранить точки', '', 'Текстовые файлы (*.txt)')

            if file_path:
                with open(file_path, 'w') as file:
                    for i in range(len(x)):
                        file.write(f'{x[i]}, {y[i]}\n')

                QMessageBox.information(self, 'Сохранение', 'Точки успешно сохранены в файл.')
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Ошибка при сохранении точек: {e}")

# Создать приложение QApplication
app = QApplication([])
# Создать окно приложения
main_window = MainWindow()
main_window.show()
# Запустить приложение
app.exec_()






from PyQt5.QtWidgets import (
 QApplication,
 QLabel,
 QLineEdit,
 QMainWindow,
 QPushButton,
 QVBoxLayout,
 QWidget,
)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.range_label = QLabel("Диапазон:")
        self.range_start_input = QLineEdit('0')
        self.range_end_input = QLineEdit('1')

        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1
        x = np.linspace(range_start, range_end, 50)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        functions = {}  # определим словарь функций
        exec(f"def f(x): return {expression}", functions)
        function = functions["f"]

        function = lambda x: x**3

        y = [function(value) for value in x]

        plt.title('Заголовок графика ' + expression)

        plt.plot(x, y)
        plt.grid(True)

        plt.xlabel('x')
        plt.ylabel('y')

        # Обновление виджета №0 (виджет с полотном Matplotlib)
        self.centralWidget().layout().itemAt(0).widget().draw()

# Создать приложение QApplication
app = QApplication([])
# Создать окно приложения
main_window = MainWindow()
main_window.show()
# Запустить приложение
app.exec_()





 2 решение
from PyQt5.QtWidgets import (QApplication, QLabel, QLineEdit, QMainWindow, QPushButton, QFormLayout, QWidget, QComboBox)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas


class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        self.setWindowTitle('График')
        self.fig = plt.figure()
        self.canvas = FigureCanvas(self.fig)

        cental_widget = QWidget()
        layout = QFormLayout()
        cental_widget.setLayout(layout)

        layout.addWidget(self.canvas)

        self.setCentralWidget(cental_widget)

        self.plot_button = QPushButton('Нарисовать график')
        self.plot_button.clicked.connect(self.plot_data)

        self.range_label = QLabel('Выберите диапазон:')
        self.range_start_input = QLineEdit('0')
        self.range_end_input = QLineEdit('1')

        self.point_amount = QLabel('Выберите количество точек на графике:')
        self.point_input = QLineEdit('100')

        self.add_function_button = QPushButton('Добавить функцию в список')
        self.function_input = QLineEdit('*Введите функцию*')
        self.function_widget = QComboBox()
        self.function_widget.addItems(['x'])
        self.add_function_button.clicked.connect(self.add_function)

        self.clear_button = QPushButton('Очистить график')
        self.clear_button.clicked.connect(self.clear_plot)

        self.file_button = QPushButton('Сохранить точки в файл')
        self.file_button.clicked.connect(self.file_save)

        layout.addWidget(self.function_widget)
        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)
        layout.addWidget(self.point_amount)
        layout.addWidget(self.point_input)
        layout.addWidget(self.plot_button)
        layout.addWidget(self.clear_button)
        layout.addWidget(self.file_button)
        layout.addRow(self.add_function_button, self.function_input)

    def vectors(self):
        try:
            expression = self.function_widget.currentText()
        except NameError:
            expression = 'x'

        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
            points = int(self.point_input.text())
        except ValueError:
            range_start = 0
            range_end = 1
            points = 50
        plt.title('График функции ' + expression)
        functions = {}
        exec(f'def f(x): return {expression}', functions)

        x = np.linspace(range_start, range_end, points)
        function = functions['f']
        try:
            y = [function(value) for value in x]
        except NameError:
            y = [value for value in x]

        return x, y

    def plot_data(self):

        x, y = self.vectors()
        axes = plt.subplot()
        axes.plot(x, y)
        plt.grid(True)
        plt.xlabel('x')
        plt.ylabel('y')

        self.centralWidget().layout().itemAt(0).widget().draw()

    def clear_plot(self):
        for ax in self.fig.axes:
            ax.clear()
        plt.grid(True)
        self.canvas.draw()

    def file_save(self):
        x, y = self.vectors()
        file = open('dots.txt', 'w')
        file.write('x' + ' ' + 'y\n')
        for i in range(len(x)):
            a, b = map(str, (x[i], y[i]))
            a, b = a[0:6], b[0:6]
            if len(a) < 6:
                a += '0' * (6 - len(a))
            if len(b) < 6:
                b += '0' * (6 - len(b))
            file.write(a + '  ' + b + '\n')

    def add_function(self):
        text_x = self.function_input.text()
        self.function_widget.addItems([text_x])


app = QApplication([])
main_window = MainWindow()
main_window.show()
app.exec()




















from PyQt5.QtWidgets import (
 QApplication,
 QLabel,
 QLineEdit,
 QMainWindow,
 QPushButton,
 QVBoxLayout,
 QWidget,
)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.range_label = QLabel("Диапазон:")
        self.range_start_input = QLineEdit('0')
        self.range_end_input = QLineEdit('1')

        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1
        x = np.linspace(range_start, range_end, 50)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        functions = {}  # определим словарь функций
        exec(f"def f(x): return {expression}", functions)
        function = functions["f"]

        function = lambda x: x**3

        y = [function(value) for value in x]

        plt.title('Заголовок графика ' + expression)

        plt.plot(x, y)
        plt.grid(True)

        plt.xlabel('x')
        plt.ylabel('y')

        # Обновление виджета №0 (виджет с полотном Matplotlib)
        self.centralWidget().layout().itemAt(0).widget().draw()




С ТОЧКАМИ
from PyQt5.QtWidgets import (
 QApplication,
 QLabel,
 QLineEdit,
 QMainWindow,
 QPushButton,
 QVBoxLayout,
 QWidget,
 QSpinBox
)
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas

class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super(MainWindow, self).__init__(parent)

        # Назначим заголовок окна
        self.setWindowTitle("График")

        # Создание виджетов
        self.canvas = FigureCanvas(plt.figure()) # Создание полотна Matplotlib

        # Создание центрального виджета
        central_widget = QWidget()
        layout = QVBoxLayout() # макет, на который будут добавляться виджеты
        central_widget.setLayout(layout) # добавление макета на центральный виджет

        # Добавление виджетов на макет
        layout.addWidget(self.canvas)

        # Установка центрального виджета
        self.setCentralWidget(central_widget)

        # Вызов функции рисования графика
        # self.plot_data()

        self.plot_button = QPushButton("Нарисовать график")
        self.plot_button.clicked.connect(self.plot_data)

        layout.addWidget(self.plot_button)

        self.range_label = QLabel("Диапазон:")
        self.range_start_input = QLineEdit('-1')
        self.range_end_input = QLineEdit('1')

        layout.addWidget(self.range_label)
        layout.addWidget(self.range_start_input)
        layout.addWidget(self.range_end_input)

        self.function_label = QLabel("Функция:")
        self.function_input = QLineEdit('x**3')

        layout.addWidget(self.function_label)
        layout.addWidget(self.function_input)

        self.points_label = QLabel("Количество точек:")
        self.points_input = QSpinBox()
        self.points_input.setMinimum(2)  # Минимальное количество точек
        self.points_input.setMaximum(1000)  # Максимальное количество точек
        self.points_input.setValue(50)  # Значение по умолчанию
        layout.addWidget(self.points_label)
        layout.addWidget(self.points_input)

    def plot_data(self):
        try:
            range_start = float(self.range_start_input.text())
            range_end = float(self.range_end_input.text())
        except ValueError:
            range_start = 0
            range_end = 1

        # Получаем количество точек из QSpinBox
        num_points = self.points_input.value()

        x = np.linspace(range_start, range_end, num_points)

        try:
            expression = self.function_input.text()
        except ValueError:
            expression = "x**3"

        functions = {}  # определим словарь функций
        exec(f"def f(x): return {expression}", functions)
        function = functions["f"]

        y = [function(value) for value in x]

        plt.title('Заголовок графика ' + expression)

        plt.plot(x, y)
        plt.grid(True)

        plt.xlabel('x')
        plt.ylabel('y')

        # Обновление виджета №0 (виджет с полотном Matplotlib)
        self.centralWidget().layout().itemAt(0).widget().draw()

# Создать приложение QApplication
app = QApplication([])
# Создать окно приложения
main_window = MainWindow()
main_window.show()
# Запустить приложение
app.exec_()
